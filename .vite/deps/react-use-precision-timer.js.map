{
  "version": 3,
  "sources": ["../../node_modules/react-sub-unsub/dist/index.js", "../../node_modules/react-use-precision-timer/dist/components/TimerRenderer.js", "../../node_modules/react-use-precision-timer/dist/hooks/useTimer.js", "../../node_modules/react-use-precision-timer/dist/hooks/useDelay.js", "../../node_modules/react-use-precision-timer/dist/hooks/useStopwatch.js", "../../node_modules/react-use-precision-timer/dist/hooks/useMomentaryBool.js", "../../node_modules/react-use-precision-timer/dist/index.js"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subs = exports.Subscribe = void 0;\n/**\n * Static functions for subscribing and unsubscribing to and from events.\n */\nclass Subscribe {\n    /**\n     * Call a function that adds a listener and returns a function that will unsubscribe the listener.\n     *\n     * The function passed in will be called immediately to add the listener,\n     * and its Unsubscribe function will be returned.\n     *\n     * @param subscribe The subscribe function, which returns an Unsubscribe. Will be called immediately.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    static subscribe(subscribe) {\n        try {\n            return subscribe();\n        }\n        catch (e) {\n            console.error(e);\n        }\n        return () => {\n            // No-op when catching an error\n        };\n    }\n    /**\n     * Subscribe to an emitter event. Returns a function that will unsubscribe the listener.\n     *\n     * @param eventEmitter The [EventEmitter](https://nodejs.org/api/events.html#class-eventemitter) to subscribe to.\n     * @param eventName The name of the event to listen for.\n     * @param listener The listener callback that is called when the event occurs.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    static subscribeEvent(eventEmitter, eventName, listener) {\n        eventEmitter.addListener(eventName, listener);\n        return () => {\n            eventEmitter.removeListener(eventName, listener);\n        };\n    }\n    /**\n     * Appends an event listener for events whose type attribute value is type. The callback argument sets the callback\n     * that will be invoked when the event is dispatched.\n     *\n     * The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the\n     * method behaves exactly as if the value was specified as options's capture.\n     *\n     * When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute\n     * value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute\n     * value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.\n     *\n     * Returns a function that will unsubscribe the listener.\n     *\n     * @param domObj The DOM object to subscribe to for events.\n     * @param eventName The name of the event to listen for.\n     * @param listener The listener callback that is called when the event occurs.\n     * @param options Listener-specific options. See function description.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    static subscribeDOMEvent(domObj, eventName, listener, options) {\n        domObj.addEventListener(eventName, listener, options);\n        return () => {\n            domObj.removeEventListener(eventName, listener, options);\n        };\n    }\n    /**\n     * Sets a timer which executes a function once the timer expires using `setTimeout`.\n     * Returns an unsubscribe function that clears the timeout using `clearTimeout`.\n     *\n     * @param handler A function to be executed after the timer expires.\n     * @param delay The time, in milliseconds that the timer should wait before the specified function or code is executed. If this parameter is omitted, a value of 0 is used, meaning execute \"immediately\", or more accurately, the next event cycle.\n     * @param args Additional arguments which are passed through to the handler specified.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    static setTimeout(handler, delay, ...args) {\n        const timeout = setTimeout(handler, delay, args);\n        return () => clearTimeout(timeout);\n    }\n    /**\n     * Repeatedly calls a function with a fixed time delay between each call using `setInterval`.\n     * Returns an unsubscribe function that clears the interval using `clearInterval`.\n     *\n     * @param handler A function to be executed after the timer expires.\n     * @param delay The time, in milliseconds (thousandths of a second), the timer should delay in between executions of the specified function or code. Defaults to 0 if not specified.\n     * @param args Additional arguments which are passed through to the handler once the timer expires.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    static setInterval(handler, delay, ...args) {\n        const interval = setInterval(handler, delay, args);\n        return () => clearInterval(interval);\n    }\n    /**\n     * Call all unsubscribe functions passed in. Can pass either an array of unsubscribe functions,\n     * or a single unsubscribe function.\n     *\n     * @param unsubs An array of unsubscribe functions, or a single unsubscribe function.\n     */\n    static unsubAll(unsubs) {\n        if (Array.isArray(unsubs)) {\n            unsubs.forEach((unsub) => {\n                try {\n                    unsub();\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            });\n        }\n        else {\n            try {\n                unsubs();\n            }\n            catch (e) {\n                console.error(e);\n            }\n        }\n    }\n    /**\n     * Creates and returns a cleanup function that, when called, calls all unsubscribe functions provided.\n     *\n     * @param unsubs All subscriptions to be unsubscribed when the returned cleanup function is called.\n     * @returns A cleanup function that unsubscribes all subscriptions provided.\n     */\n    static createCleanup(unsubs) {\n        return () => Subscribe.unsubAll(unsubs);\n    }\n}\nexports.Subscribe = Subscribe;\n/**\n * A Subs object can be used to subscribe and unsubscribe to events,\n * and to collect subscriptions in an array to be unsubscribed all at once.\n *\n * Calling any of the subscribe functions will add the unsubscribe function to\n * an internal array. You can then call `unsubAll()` to unsubscribe all\n * at once and clear the list.\n */\nclass Subs {\n    /**\n     * Construct a new Subs object.\n     *\n     * A Subs object can be used to subscribe and unsubscribe to events,\n     * and to collect subscriptions in an array to be unsubscribed all at once.\n     *\n     * Calling any of the subscribe functions will add the unsubscribe function to\n     * an internal array. You can then call `unsubAll()` to unsubscribe all\n     * at once and clear the list.\n     *\n     * You can optionally pass in an array of unsubscribe functions to start with.\n     *\n     * @param list Optional array of unsubscribe functions. Defaults to an empty list.\n     */\n    constructor(\n    /** A list of unsubscribe functions for all subscribe calls that have been made. */\n    list = []) {\n        this.list = list;\n    }\n    /**\n     * Call a function that adds a listener and returns a function that will unsubscribe the listener.\n     *\n     * The function passed in will be called immediately to add the listener,\n     * and its Unsubscribe function will be returned.\n     *\n     * The Unsubscribe function will be added to the internal list of unsubs. You can unsubscribe all by calling `unsubAll()`.\n     *\n     * @param subscribe The subscribe function, which returns an Unsubscribe. Will be called immediately.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    subscribe(subscribe) {\n        const unsub = Subscribe.subscribe(subscribe);\n        this.push(unsub);\n        return unsub;\n    }\n    /**\n     * Subscribe to an emitter event. Returns a function that will unsubscribe the listener.\n     *\n     * The Unsubscribe function will be added to the internal list of unsubs. You can unsubscribe all by calling `unsubAll()`.\n     *\n     * @param eventEmitter The [EventEmitter](https://nodejs.org/api/events.html#class-eventemitter) to subscribe to.\n     * @param eventName The name of the event to listen for.\n     * @param listener The listener callback that is called when the event occurs.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    subscribeEvent(eventEmitter, eventName, listener) {\n        const unsub = Subscribe.subscribeEvent(eventEmitter, eventName, listener);\n        this.push(unsub);\n        return unsub;\n    }\n    /**\n     * Subscribe to an event on a DOM object (Window or Node). Returns a function that will unsubscribe the listener.\n     *\n     * The Unsubscribe function will be added to the internal list of unsubs. You can unsubscribe all by calling `unsubAll()`.\n     *\n     * @param domObj The DOM object to subscribe to for events.\n     * @param eventName The name of the event to listen for.\n     * @param listener The listener callback that is called when the event occurs.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    subscribeDOMEvent(domObj, eventName, listener) {\n        const unsub = Subscribe.subscribeDOMEvent(domObj, eventName, listener);\n        this.push(unsub);\n        return unsub;\n    }\n    /**\n     * Sets a timer which executes a function once the timer expires using `setTimeout`.\n     * Returns an unsubscribe function that clears the timeout using `clearTimeout`.\n     *\n     * The Unsubscribe function will be added to the internal list of unsubs. You can unsubscribe all by calling `unsubAll()`.\n     *\n     * @param handler A function to be executed after the timer expires.\n     * @param delay The time, in milliseconds that the timer should wait before the specified function or code is executed. If this parameter is omitted, a value of 0 is used, meaning execute \"immediately\", or more accurately, the next event cycle.\n     * @param args Additional arguments which are passed through to the handler specified.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    setTimeout(handler, delay, ...args) {\n        const timeout = setTimeout(handler, delay, args);\n        const unsub = () => clearTimeout(timeout);\n        this.push(unsub);\n        return unsub;\n    }\n    /**\n     * Repeatedly calls a function with a fixed time delay between each call using `setInterval`.\n     * Returns an unsubscribe function that clears the interval using `clearInterval`.\n     *\n     * The Unsubscribe function will be added to the internal list of unsubs. You can unsubscribe all by calling `unsubAll()`.\n     *\n     * @param handler A function to be executed after the timer expires.\n     * @param delay The time, in milliseconds (thousandths of a second), the timer should delay in between executions of the specified function or code. Defaults to 0 if not specified.\n     * @param args Additional arguments which are passed through to the handler once the timer expires.\n     * @returns The Unsubscribe function for this subscription.\n     */\n    setInterval(handler, delay, ...args) {\n        const interval = setInterval(handler, delay, args);\n        const unsub = () => clearInterval(interval);\n        this.push(unsub);\n        return unsub;\n    }\n    /**\n     * Pushes an unsubscribe function onto the subscription list.\n     *\n     * You can unsubscribe all by calling `unsubAll()`.\n     *\n     * @param unsub The unsubscribe function to push to the subscription list.\n     */\n    push(unsub) {\n        this.list.push(unsub);\n    }\n    /**\n     * Call all unsubscribe functions and clear the unsubscribe list.\n     */\n    unsubAll() {\n        Subscribe.unsubAll(this.list);\n        // Empty the array, maintain the reference\n        this.list.splice(0, this.list.length);\n    }\n    /**\n     * Creates and returns a cleanup function that, when called, calls all unsubscribe functions and clears the unsubscribe list.\n     *\n     * @returns A cleanup function that unsubscribes all subscriptions and clears the unsubscribe list.\n     */\n    createCleanup() {\n        return () => {\n            this.unsubAll();\n        };\n    }\n}\nexports.Subs = Subs;\n", "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TimerRenderer = void 0;\nconst react_1 = __importDefault(require(\"react\"));\nconst react_sub_unsub_1 = require(\"react-sub-unsub\");\n/**\n * Renders a timer or stopwatch at regular intervals.\n */\nconst TimerRenderer = ({ timer, render = (timer) => react_1.default.createElement(react_1.default.Fragment, null, timer.getElapsedRunningTime()), renderRate = 10, }) => {\n    const [, setRenderTime] = react_1.default.useState(Date.now());\n    react_1.default.useEffect(() => {\n        const subs = new react_sub_unsub_1.Subs();\n        subs.setInterval(() => setRenderTime(new Date().getTime()), renderRate);\n        return subs.createCleanup();\n    }, [renderRate]);\n    return render(timer);\n};\nexports.TimerRenderer = TimerRenderer;\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useTimer = void 0;\nconst React = __importStar(require(\"react\"));\nconst react_sub_unsub_1 = require(\"react-sub-unsub\");\n/** Milliseconds representing forever in the future. */\nconst never = Number.MAX_SAFE_INTEGER;\n/**\n * See documentation: [useTimer](https://justinmahar.github.io/react-use-precision-timer/?path=/story/docs-usetimer--docs)\n *\n * A versatile precision timer hook for React. Doubles as a stopwatch.\n *\n * - Based on `setTimeout()` and timestamps, not `setInterval()` or ticks.\n * - Features perfect mean interval accuracy, meaning it doesn't wander.\n * - Resilient to expensive callback operations and low timer delays.\n * - Can be used as a timer or a stopwatch.\n * - Supports starting, stopping, pausing, and resuming.\n * - Includes accessors for everything under the sun.\n *\n * @param options The TimerOptions for the timer.\n * @param callback The callback to call when the timer fires. Use React.useCallback() for this. Must provide a `delay` for the timer to fire. If you'd like, you can determine if any calls were missed by checking the `overdueCallCount` argument. This value will indicate how many calls were missed due to a very short timer delay or time-consuming callback.\n */\nconst useTimer = (options = {}, callback) => {\n    const [firstRun, setFirstRun] = React.useState(true);\n    const [renderTime, setRenderTime] = React.useState(Date.now());\n    const startedRef = React.useRef(false);\n    const startTimeRef = React.useRef(never);\n    const lastFireTimeRef = React.useRef(never);\n    const nextFireTimeRef = React.useRef(never);\n    const pauseTimeRef = React.useRef(never);\n    const resumeTimeRef = React.useRef(never);\n    const periodElapsedPauseTimeRef = React.useRef(0);\n    const totalElapsedPauseTimeRef = React.useRef(0);\n    // Memoized options\n    const delay = React.useMemo(() => {\n        var _a, _b;\n        const s = (_a = options.speedMultiplier) !== null && _a !== void 0 ? _a : 1;\n        const d = (_b = options.delay) !== null && _b !== void 0 ? _b : 0;\n        return s === 0 ? 0 : s > 0 && d > 0 ? Math.max(1, Math.round(d * (1 / s))) : d;\n    }, [options.delay, options.speedMultiplier]);\n    const runOnce = React.useMemo(() => options.runOnce, [options.runOnce]);\n    const fireOnStart = React.useMemo(() => options.fireOnStart, [options.fireOnStart]);\n    const startImmediately = React.useMemo(() => options.startImmediately, [options.startImmediately]);\n    const isStarted = React.useCallback(() => {\n        return startedRef.current;\n    }, []);\n    const isStopped = React.useCallback(() => {\n        return !isStarted();\n    }, [isStarted]);\n    const isPaused = React.useCallback(() => {\n        return isStarted() && pauseTimeRef.current !== never;\n    }, [isStarted]);\n    const isRunning = React.useCallback(() => {\n        return isStarted() && !isPaused();\n    }, [isPaused, isStarted]);\n    const getEffectiveDelay = React.useCallback(() => {\n        return delay;\n    }, [delay]);\n    const getStartTime = React.useCallback(() => {\n        if (isStarted()) {\n            return startTimeRef.current;\n        }\n        return -1;\n    }, [isStarted]);\n    const getLastFireTime = React.useCallback(() => {\n        return lastFireTimeRef.current < never && !!delay ? lastFireTimeRef.current : -1;\n    }, [delay]);\n    const getNextFireTime = React.useCallback(() => {\n        if (isRunning() && !!delay) {\n            return nextFireTimeRef.current;\n        }\n        return -1;\n    }, [isRunning, delay]);\n    const getPauseTime = React.useCallback(() => {\n        if (isPaused()) {\n            return pauseTimeRef.current;\n        }\n        return -1;\n    }, [isPaused]);\n    const getResumeTime = React.useCallback(() => {\n        if (isStarted() && resumeTimeRef.current < never) {\n            return resumeTimeRef.current;\n        }\n        return -1;\n    }, [isStarted]);\n    const getElapsedStartedTime = React.useCallback(() => {\n        if (isStarted()) {\n            return Date.now() - startTimeRef.current;\n        }\n        return 0;\n    }, [isStarted]);\n    const getElapsedRunningTime = React.useCallback(() => {\n        if (isStarted()) {\n            if (isPaused()) {\n                return pauseTimeRef.current - startTimeRef.current - totalElapsedPauseTimeRef.current;\n            }\n            else {\n                return Date.now() - startTimeRef.current - totalElapsedPauseTimeRef.current;\n            }\n        }\n        return 0;\n    }, [isPaused, isStarted]);\n    const getPeriodElapsedPausedTime = React.useCallback(() => {\n        let additionalElapsedPauseTime = 0;\n        if (isPaused()) {\n            additionalElapsedPauseTime = Date.now() - pauseTimeRef.current;\n        }\n        return periodElapsedPauseTimeRef.current + additionalElapsedPauseTime;\n    }, [isPaused]);\n    const getTotalElapsedPausedTime = React.useCallback(() => {\n        let additionalElapsedPauseTime = 0;\n        if (isPaused()) {\n            additionalElapsedPauseTime = Date.now() - pauseTimeRef.current;\n        }\n        return totalElapsedPauseTimeRef.current + additionalElapsedPauseTime;\n    }, [isPaused]);\n    const getElapsedResumedTime = React.useCallback(() => {\n        if (isRunning()) {\n            return Date.now() - resumeTimeRef.current;\n        }\n        return 0;\n    }, [isRunning]);\n    const getRemainingTime = React.useCallback(() => {\n        const currentTime = Date.now();\n        if (isStarted() && !!delay) {\n            if (isRunning()) {\n                return Math.max(0, nextFireTimeRef.current - currentTime);\n            }\n            else if (isPaused()) {\n                const edgeTime = lastFireTimeRef.current !== never ? lastFireTimeRef.current : startTimeRef.current;\n                return Math.max(0, delay - (pauseTimeRef.current - edgeTime - periodElapsedPauseTimeRef.current));\n            }\n        }\n        return 0;\n    }, [isPaused, isRunning, isStarted, delay]);\n    const start = React.useCallback((startTimeMillis = Date.now()) => {\n        const newNextFireTime = delay\n            ? Math.max(startTimeMillis, fireOnStart ? startTimeMillis : startTimeMillis + delay)\n            : never;\n        startTimeRef.current = startTimeMillis;\n        lastFireTimeRef.current = never;\n        nextFireTimeRef.current = newNextFireTime;\n        pauseTimeRef.current = never;\n        resumeTimeRef.current = startTimeMillis;\n        periodElapsedPauseTimeRef.current = 0;\n        totalElapsedPauseTimeRef.current = 0;\n        startedRef.current = true;\n        setRenderTime(Date.now());\n    }, [delay, fireOnStart]);\n    const stop = React.useCallback(() => {\n        startTimeRef.current = never;\n        lastFireTimeRef.current = never;\n        nextFireTimeRef.current = never;\n        pauseTimeRef.current = never;\n        resumeTimeRef.current = never;\n        periodElapsedPauseTimeRef.current = 0;\n        totalElapsedPauseTimeRef.current = 0;\n        startedRef.current = false;\n        setRenderTime(Date.now());\n    }, []);\n    const pause = React.useCallback(() => {\n        if (isRunning()) {\n            pauseTimeRef.current = Date.now();\n            resumeTimeRef.current = never;\n            setRenderTime(Date.now());\n        }\n    }, [isRunning]);\n    const resume = React.useCallback(() => {\n        if (isStarted() && isPaused()) {\n            const currentTime = Date.now();\n            nextFireTimeRef.current = currentTime + getRemainingTime();\n            periodElapsedPauseTimeRef.current = 0;\n            totalElapsedPauseTimeRef.current = totalElapsedPauseTimeRef.current + (currentTime - pauseTimeRef.current);\n            pauseTimeRef.current = never;\n            resumeTimeRef.current = currentTime;\n            setRenderTime(Date.now());\n        }\n    }, [isStarted, isPaused, getRemainingTime]);\n    React.useEffect(() => {\n        const subs = new react_sub_unsub_1.Subs();\n        const checkTimer = () => {\n            // If it's a timer and it isn't paused...\n            if (delay && !isPaused()) {\n                const now = Date.now();\n                // If the timer is up...\n                if (now >= nextFireTimeRef.current) {\n                    // Check if we're overdue on any events being fired (super low delay or expensive callback).\n                    // To do this, we divide the time elapsed beyond the next expected fire time by the delay,\n                    // and floor the result. In other words, find how overdue we are, then divide by the delay.\n                    const overdueCalls = lastFireTimeRef.current !== never ? Math.max(0, Math.floor((now - nextFireTimeRef.current) / delay)) : 0;\n                    lastFireTimeRef.current = now;\n                    periodElapsedPauseTimeRef.current = 0;\n                    // Calculate and set the next time the timer should fire, accounting for overdue calls (if any)\n                    const overdueElapsedTime = overdueCalls * delay;\n                    const newFireTime = Math.max(now, nextFireTimeRef.current + delay + overdueElapsedTime);\n                    nextFireTimeRef.current = newFireTime;\n                    // Call the callback\n                    if (typeof callback === 'function') {\n                        try {\n                            callback(overdueCalls);\n                        }\n                        catch (e) {\n                            console.error(e);\n                        }\n                    }\n                    // If it repeats\n                    if (!runOnce) {\n                        // Set a timeout to check and fire the timer when time's up\n                        subs.setTimeout(() => {\n                            // Check if the timer can fire\n                            checkTimer();\n                        }, Math.max(newFireTime - Date.now(), 1));\n                    }\n                    else {\n                        // If it doesn't repeat, stop the timer.\n                        stop();\n                    }\n                }\n                // Time is not up yet. Set a timeout to check and fire when time's up\n                else if (nextFireTimeRef.current < never) {\n                    subs.setTimeout(() => {\n                        // Check if the timer can fire\n                        checkTimer();\n                        // Home in on the exact time to fire.\n                    }, Math.max(nextFireTimeRef.current - Date.now(), 1));\n                }\n            }\n        };\n        // Check if the timer can fire\n        checkTimer();\n        return subs.createCleanup();\n    }, [callback, delay, isPaused, renderTime, runOnce, stop]);\n    // Start immediately if this is our first run.\n    React.useEffect(() => {\n        if (firstRun) {\n            setFirstRun(false);\n            if (startImmediately) {\n                start();\n            }\n        }\n    }, [firstRun, startImmediately, start]);\n    return React.useMemo(() => {\n        return {\n            start,\n            stop,\n            pause,\n            resume,\n            isStarted,\n            isStopped,\n            isRunning,\n            isPaused,\n            getEffectiveDelay,\n            getStartTime,\n            getLastFireTime,\n            getNextFireTime,\n            getPauseTime,\n            getResumeTime,\n            getRemainingTime,\n            getElapsedStartedTime,\n            getElapsedRunningTime,\n            getTotalElapsedPausedTime,\n            getPeriodElapsedPausedTime,\n            getElapsedResumedTime,\n        };\n    }, [\n        getEffectiveDelay,\n        getElapsedResumedTime,\n        getElapsedRunningTime,\n        getElapsedStartedTime,\n        getLastFireTime,\n        getNextFireTime,\n        getPauseTime,\n        getPeriodElapsedPausedTime,\n        getRemainingTime,\n        getResumeTime,\n        getStartTime,\n        getTotalElapsedPausedTime,\n        isPaused,\n        isRunning,\n        isStarted,\n        isStopped,\n        pause,\n        resume,\n        start,\n        stop,\n    ]);\n};\nexports.useTimer = useTimer;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useDelay = void 0;\nconst useTimer_1 = require(\"./useTimer\");\n/**\n * See documentation: [useDelay](https://justinmahar.github.io/react-use-precision-timer/useDelay)\n *\n * Fires the callback after the specified delay has passed. Call start() on the returned Timer to execute.\n *\n * @param delay The amount of time, in milliseconds, before the timer fires.\n * @param callback Called when the timer fires. Use React.useCallback() for this.\n */\nconst useDelay = (delay, callback) => {\n    return (0, useTimer_1.useTimer)({ delay, runOnce: true }, callback);\n};\nexports.useDelay = useDelay;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useStopwatch = void 0;\nconst useTimer_1 = require(\"./useTimer\");\n/**\n * See documentation: [useStopwatch](https://justinmahar.github.io/react-use-precision-timer/useStopwatch)\n *\n * Runs indefinitely, counting elapsed time, until paused or stopped.\n */\nconst useStopwatch = () => {\n    return (0, useTimer_1.useTimer)();\n};\nexports.useStopwatch = useStopwatch;\n", "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useMomentaryBool = void 0;\nconst react_1 = __importDefault(require(\"react\"));\nconst useDelay_1 = require(\"./useDelay\");\nconst useMomentaryBool = (initial, delay) => {\n    const [state, setState] = react_1.default.useState(initial);\n    const callback = react_1.default.useCallback(() => setState(initial), [initial]);\n    const onceTimer = (0, useDelay_1.useDelay)(delay, callback);\n    const toggle = react_1.default.useCallback(() => {\n        setState(!initial);\n        onceTimer.start();\n    }, [onceTimer, initial]);\n    return [state, toggle];\n};\nexports.useMomentaryBool = useMomentaryBool;\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Components\n__exportStar(require(\"./components/TimerRenderer\"), exports);\n// Hooks\n__exportStar(require(\"./hooks/useDelay\"), exports);\n__exportStar(require(\"./hooks/useStopwatch\"), exports);\n__exportStar(require(\"./hooks/useTimer\"), exports);\n__exportStar(require(\"./hooks/useMomentaryBool\"), exports);\n"],
  "mappings": "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",
  "names": ["timer", "require_dist", "exports"]
}
